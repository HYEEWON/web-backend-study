# Index

## 🐳 정의 및 특징
추가적인 쓰기 작업과 저장 공간을 활용하여 DB 테이블의 검색 속도를 향상시키기 위한 자료구조
인덱스를 사용하면 SELECT, UPDATE, DELETE 성능 모두 향상
테이블에 데이터의 추가, 삭제, 수정이 자주 발생하면 인덱스도 변경해야 해서 성능이 떨어질 수 있음
인덱스는 INSERT, UPDATE, DELETE가 자주 발생하지 않고, SELECT(JOIN, WHERE, ORDER BY)가 자주 발생하는 컬럼에 사용하면 좋음

## 🐳 종류
  (1) 클러스터형 인덱스 (Clustered Index, Primary Index)

인덱스로 구성된 컬럼을 기준으로 정렬하여 사용되는 인덱스
물리적으로 행을 재배열(기본적으로 오름차순) → 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지
테이블 당 1개씩 허용
용량 차지가 작음: 리프 페이지가 없어도 돼서 비 클러스터형 인덱스보다 용량을 적게 차지
정렬 → 검색 속도는 빠르지만, 데이터의 입력/수정/삭제는 느림
정렬 → 범위 검색에 좋음
테이블에서 기본키인 컬럼은 자동으로 클러스터 인덱스가 됨 → 기본키가 아닌 컬럼도 클러스터형 인덱스로 사용 가능
    (더하기) Page Split: INSERT 작업에서 페이지에 새로운 데이터를 넣을 자리가 없으면, 새로운 페이지를 생성하고 데이터 추가 및 이동이 발생

  (2) 비 클러스터형 인덱스 (Non Clustered Index, Secondary Index)

데이터의 위치를 알려주는 인덱스 페이지를 인덱스로 구성된 컬럼 값을 기준으로 정렬하여 이용하는 인덱스
물리적으로 행을 재배열하지 않음, 인덱스 페이지만 정렬
테이블에 여러 개 허용 (249개)
용량 차지가 큼: 별도의 공간에 인덱스 페이지를 생성
검색 속도는 느리지만, 데이터의 입력/수정/삭제는 빠름
범위 검색에 나쁨 (Table Scan이 더 빠를 수도 있어 인덱스를 사용하지 않기도 함)
Unique이면 비 클러스터형 인덱스로 지정

  (3) Covered Index (Covering Index)

인덱스만 이용해서 쿼리의 결과를 얻을 수 있는 인덱스
쿼리에서 사용되는 모든 컬럼이 인덱스의 구성 요소인 인덱스
데이터에 접근하지 않고 인덱스만 접근하여 처리 → Disk I/O 감소
인덱스는 테이블보다 크기가 작고, 키 값에 따라 정렬되어 Sequential Read가 가능 → 성능 향상

## 🐳 구조
  (더하기) Page: 데이터 파일을 구성하는 논리 단위 (8KB)

  (1) 루트 레벨/루트 페이지

인덱스 페이지의 가장 상위 수준으로 1개만 존재
인덱스 검색의 시작점으로 SQL-Server는 내부적으로 각각의 루트 페이지에 대한 위치 정보를 기록/저장
  (2) 중간 레벨

인덱스 크기에 따라 존재할수도 있고 안할수도 있음
일반적으로 1~2개의 중간 레벨을 가짐
  (3) 리프 레벨/리프 페이지

인덱스 페이지의 최하위 수준
  (4) 인덱스에서의 구조

## MSSQL 예시