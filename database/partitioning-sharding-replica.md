# ➕ 파티셔닝 (Partitioning)

## 🎠 정의
* `하나의 DB`에서 데이터를 물리적으로 분할하는 것
* 튜닝 기법: 데이터 용량 증가 시의 성능 향상, 관리 용이를 위해 진행

## 🎠 장점
* 관리 용이: 큰 테이블을 제거하여 관리가 쉬움
* 읽기/쓰기 성능 향상
* Insert 시에 분리된 파티션으로 분산시켜 경합을 줄임

## 🎠 단점
* 조인 비용 증가
* 테이블과 인덱스를 별도로 분리할 수 없고, 함께 분리해야 됨

## 🎠 분할 방법

![image](https://user-images.githubusercontent.com/38900338/139434725-01585de7-86d9-41dc-af13-17c120de5584.png)

### 👉 수평 분할 (Horizontal Partitioning)
* 하나의 DB안에 스키마가 같은 데이터를 두 개 이상의 테이블에 분할하여 저장
* 예시
  * 주민 테이블 -> a동 테이블, b동 테이블로 분리
### 👉 수직 분할 (Vertical Partitioning)
* 테이블을 열을 기준으로 분리
* 정규화된 테이블을 분리하는 것

## 🎠 분할 기준
### 👉 범위 분할 (Range Partitioning)
* `연속적인 값의 범위`로 분할
* 파티션 별로 크기 다름
* 파티션 분할/병합이 비교적 쉬움
* 예시
  * 년도 범위로 분할 -> P1: 2000년 이전, P2: 2000년 초과
### 👉 목록 분할 (List Partitioning)
* `이산적인 값`으로 분할
* 파티션 별로 크기 다름
* 파티션 분할/병합이 비교적 쉬움
* 예시
  * 국가 컬럼: 지역별로 분할 가능 -> P1: 한국, 일본, P2: 영국, 프랑스, 스위스
### 👉 해시 분할 (Hash Partitioning)
* `해시 값`으로 분할
  * 4개 -> 0~3의 해시 값으로 분할
* 파티션 별로 크기 동일
* 파티션 분할/병합이 어려움 -> 파티션이 추가/삭제될 때 Global Relocation 발생
* 특정 데이터가 어느 Hash Partition에 있는지 판단 불가
* 파티션을 위한 범위가 없는 데이터에 적합

<br>

# ➕ 샤딩 (Sharding)

## 🎠 정의

* `여러 DB`에 데이터를 물리적으로 `수평 분할 방식(Horizontal Partitioning)`으로 분산 저장/조회하는 것
* `트래픽 분산` 목적으로 사용: 데이터베이스에 데이터 증가 -> 용량 이슈, CRUD 성능 저하
* 애플리케이션 서버 레벨에서 구현하는 경우가 많았으나 최근에는 플랫폼 차원에서도 제공
  * Hibernate Shards, Spock Proxy(MySQL Proxy 기반), Gizzard(Twitter), Spider(MariaDB 기본 내장)
* 예시
  * 주민 테이블 -> a동 테이블은 A DB, b동 테이블은 B DB에 저장

## 🎠 장점
* 쓰기 성능 향상 (읽기 성능 동일)

## 🎠 단점
* 두 개 이상의 샤드에서 `JOIN 불가`
* 일관성과 복제에서 불리
* auto increment 등은 샤드 별로 달라질 수 있고, last_insert_id() 값은 유효하지 않음

## 🎠 종류
### 👉 Modular Sharding
* PK를 모듈러 연산한 결과로 DB를 특정하는 방식
* 데이터 양이 일정할 것으로 예상되는 경우 사용 (EX. 콘텐츠의 유지 시간이 5시간)
* 장점: 데이터가 균일하게 분산됨
* 단점: DB를 증설하면 데이터의 재정렬이 필요
### 👉 Range Sharding
* PK의 범위를 기준으로 DB를 특정하는 방식
* 장점 : DB 증설에 재정렬 비용이 들지 않음
* 단점 : 일부 DB에 데이터가 몰릴 수 있음 (EX. 활성 유저가 많은 DB로 트래픽/데이터가 쏠릴 수 있음)

## 🎠 주의사항
* 샤딩은 프로그래밍/운영의 `복잡도를 향상`시키는 단점이 있음
* 가능하면 피하는 것이 좋음
* 대체 방안
  * Scale-In: 성능이 좋은 HW 사용
  * Read 부하가 크다면, 캐시나 Replication 적용
  * 테이블의 일부 컬럼만 자주 사용한다면, Vertical Partition 적용

<br>

# ➕ 레플리카 (Replication)

## 🎠 정의

![image](https://user-images.githubusercontent.com/38900338/139438482-86e0d8fb-be02-4c46-8c4f-f24e1b3f4811.png)

* `동일한 데이터를 Master/Slave DB로 나누어 저장`하는 것 (이중화)
* 목적
  * `읽기(Select) 성능을 향상`하기 위한 방법
  * 읽기와 쓰기 DB를 분리하여 성능을 향상시킴
  * Fail Over 방지: 메인 DB에 문제가 생겨도 서브 DB로 해결

<br>

# ➕ 비교
## 🎠 샤딩, 파티셔닝
* 데이터 분산 저장
* 데이터가 한 곳에 저장되지 않음 -> 분리되어 있는 데이터를 합쳐 연산하기 위해 어플리케이션 레이어, 플러그인, 서드파티 솔루션 등으로 극복해야 함 -> 리스크 있음

## 🎠 레플리카
* 데이터 복제 저장
* 일정 수준 이상의 지연은 생길 수밖에 없지만 이를 감안하고 지연 복제하는 경우가 일반적
